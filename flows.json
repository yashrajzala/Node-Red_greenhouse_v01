[
    {
        "id": "d1d9b412263f5851",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1b094c419d097e01",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.20.1",
        "port": 1883,
        "clientid": "node-red-greenhouse-client",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": "60",
        "cleansession": false,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "3c484dec69aaf611",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "sensor Data ",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": "60",
        "rejectUnauthorized": false
    },
    {
        "id": "28b3ebc016f19340",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": "60",
        "rejectUnauthorized": false
    },
    {
        "id": "bc849d2e7bf01c65",
        "type": "mqtt in",
        "z": "d1d9b412263f5851",
        "name": "",
        "topic": "greenhouse/+/node/+/data",
        "qos": "0",
        "datatype": "json",
        "broker": "1b094c419d097e01",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 220,
        "wires": [
            [
                "9ffc594d6035f994"
            ]
        ]
    },
    {
        "id": "9ffc594d6035f994",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Spliting data node wise",
        "func": "// High-performance data routing by node ID\nconst nodeId = msg.payload.node_id;\n\n// Pre-allocated output array for maximum performance\nlet output = [null, null, null, null, null];\n\n// Direct switch for optimal routing performance\nswitch (nodeId) {\n    case \"Node01\":\n        output[0] = msg;\n        break;\n    case \"Node02\":\n        output[1] = msg;\n        break;\n    case \"Node03\":\n        output[2] = msg;\n        break;\n    case \"Node04\":\n        output[3] = msg;\n        break;\n    case \"Node05\":\n        output[4] = msg;\n        break;\n    default:\n        // Skip unknown nodes silently for performance\n        break;\n}\n\nreturn output;",
        "outputs": 5,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 220,
        "wires": [
            [
                "fe53b5ab0fa82c07",
                "7dd44efa74b8262e"
            ],
            [
                "1541cdb02a5be7bd",
                "7dd44efa74b8262e"
            ],
            [
                "f636b86247c1d249",
                "7dd44efa74b8262e"
            ],
            [
                "97d3888d48deeceb",
                "7dd44efa74b8262e"
            ],
            [
                "a5c3778e42978939",
                "7dd44efa74b8262e"
            ]
        ]
    },
    {
        "id": "fe53b5ab0fa82c07",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Node01",
        "func": "const d = msg.payload;\n\nconst sensors = {\n    Bag_Temp: d.Bag_Temp,\n    Light_Par: d.Light_Par,\n    Air_Temp: d.Air_Temp,\n    Air_Rh: d.Air_Rh,\n    Leaf_temp: d.Leaf_temp,\n    drip_weight: d.drip_weight,\n    Bag_Rh1: d.Bag_Rh1,\n    Bag_Rh2: d.Bag_Rh2,\n    Bag_Rh3: d.Bag_Rh3,\n    Bag_Rh4: d.Bag_Rh4\n};\n\nconst payloads = [];\n\nfor (const [sensor, value] of Object.entries(sensors)) {\n    if (typeof value === \"number\") {\n        payloads.push({\n            measurement: \"sensor_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                sensor: sensor\n            },\n            fields: {\n                value: value\n            }\n            // No timestamp: InfluxDB will use system time\n        });\n    }\n}\n\nmsg.payload = payloads;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 140,
        "wires": [
            [
                "8a536c6ca63faf79"
            ]
        ]
    },
    {
        "id": "1541cdb02a5be7bd",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Node02",
        "func": "const d = msg.payload;\n\nconst sensors = {\n    Bag_Temp: d.Bag_Temp,\n    Light_Par: d.Light_Par,\n    Air_Temp: d.Air_Temp,\n    Air_Rh: d.Air_Rh,\n    Leaf_temp: d.Leaf_temp,\n    drip_weight: d.drip_weight,\n    Bag_Rh1: d.Bag_Rh1,\n    Bag_Rh2: d.Bag_Rh2,\n    Bag_Rh3: d.Bag_Rh3,\n    Bag_Rh4: d.Bag_Rh4\n};\n\nconst payloads = [];\n\nfor (const [sensor, value] of Object.entries(sensors)) {\n    if (typeof value === \"number\") {\n        payloads.push({\n            measurement: \"sensor_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                sensor: sensor\n            },\n            fields: {\n                value: value\n            }\n            // No timestamp: InfluxDB will use system time\n        });\n    }\n}\n\nmsg.payload = payloads;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 180,
        "wires": [
            [
                "8a536c6ca63faf79"
            ]
        ]
    },
    {
        "id": "f636b86247c1d249",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Node03",
        "func": "const d = msg.payload;\n\nconst sensors = {\n    Bag_Temp: d.Bag_Temp,\n    Light_Par: d.Light_Par,\n    Air_Temp: d.Air_Temp,\n    Air_Rh: d.Air_Rh,\n    Leaf_temp: d.Leaf_temp,\n    drip_weight: d.drip_weight,\n    Bag_Rh1: d.Bag_Rh1,\n    Bag_Rh2: d.Bag_Rh2,\n    Bag_Rh3: d.Bag_Rh3,\n    Bag_Rh4: d.Bag_Rh4\n};\n\nconst payloads = [];\n\nfor (const [sensor, value] of Object.entries(sensors)) {\n    if (typeof value === \"number\") {\n        payloads.push({\n            measurement: \"sensor_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                sensor: sensor\n            },\n            fields: {\n                value: value\n            }\n            // No timestamp: InfluxDB will use system time\n        });\n    }\n}\n\nmsg.payload = payloads;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 220,
        "wires": [
            [
                "8a536c6ca63faf79"
            ]
        ]
    },
    {
        "id": "97d3888d48deeceb",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Node04",
        "func": "const d = msg.payload;\n\nconst sensors = {\n    Bag_Temp: d.Bag_Temp,\n    Light_Par: d.Light_Par,\n    Air_Temp: d.Air_Temp,\n    Air_Rh: d.Air_Rh,\n    Leaf_temp: d.Leaf_temp,\n    drip_weight: d.drip_weight,\n    Bag_Rh1: d.Bag_Rh1,\n    Bag_Rh2: d.Bag_Rh2,\n    Bag_Rh3: d.Bag_Rh3,\n    Bag_Rh4: d.Bag_Rh4\n};\n\nconst payloads = [];\n\nfor (const [sensor, value] of Object.entries(sensors)) {\n    if (typeof value === \"number\") {\n        payloads.push({\n            measurement: \"sensor_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                sensor: sensor\n            },\n            fields: {\n                value: value\n            }\n            // No timestamp: InfluxDB will use system time\n        });\n    }\n}\n\nmsg.payload = payloads;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 260,
        "wires": [
            [
                "8a536c6ca63faf79"
            ]
        ]
    },
    {
        "id": "a5c3778e42978939",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Node 05",
        "func": "const d = msg.payload;\n\nconst sensors = {\n    Light_Par: d.Light_Par,\n    Air_Temp: d.Air_Temp,\n    Air_Rh: d.Air_Rh,\n    Rain: d.Rain\n};\n\nconst payloads = [];\n\nfor (const [sensor, value] of Object.entries(sensors)) {\n    if (typeof value === \"number\") {\n        payloads.push({\n            measurement: \"sensor_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                sensor: sensor\n            },\n            fields: {\n                value: value\n            }\n            // No timestamp: Let InfluxDB use server time\n        });\n    }\n}\n\nmsg.payload = payloads;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 300,
        "wires": [
            [
                "8a536c6ca63faf79"
            ]
        ]
    },
    {
        "id": "8a536c6ca63faf79",
        "type": "influxdb batch",
        "z": "d1d9b412263f5851",
        "influxdb": "3c484dec69aaf611",
        "precision": "",
        "retentionPolicy": "",
        "name": "Influx(SernsorData)",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-agriculture",
        "bucket": "SensorData",
        "x": 1010,
        "y": 220,
        "wires": []
    },
    {
        "id": "7dd44efa74b8262e",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Calculate VPD & ES values",
        "func": "const d = msg.payload;\n\nif (\n    typeof d.Air_Temp !== 'number' ||\n    typeof d.Air_Rh !== 'number' ||\n    d.Air_Rh < 0 || d.Air_Rh > 100\n) {\n    return null; // Required fields missing or out of range\n}\n\nconst output = [];\n\n// es_air and ea\nconst es_air = 0.6108 * Math.exp((17.27 * d.Air_Temp) / (d.Air_Temp + 237.3));\nconst ea = (d.Air_Rh / 100) * es_air;\n\noutput.push(\n    {\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse: d.greenhouse_id,\n            node: d.node_id,\n            metric: \"es_air\"\n        },\n        fields: {\n            value: parseFloat(es_air.toFixed(3))\n        }\n    },\n    {\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse: d.greenhouse_id,\n            node: d.node_id,\n            metric: \"ea\"\n        },\n        fields: {\n            value: parseFloat(ea.toFixed(3))\n        }\n    }\n);\n\n// es_leaf and VPD if Leaf_temp exists\nif (typeof d.Leaf_temp === 'number') {\n    const es_leaf = 0.6108 * Math.exp((17.27 * d.Leaf_temp) / (d.Leaf_temp + 237.3));\n    const vpd = Math.max(0, es_leaf - ea);\n\n    output.push(\n        {\n            measurement: \"calculated_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                metric: \"es_leaf\"\n            },\n            fields: {\n                value: parseFloat(es_leaf.toFixed(3))\n            }\n        },\n        {\n            measurement: \"calculated_data\",\n            tags: {\n                greenhouse: d.greenhouse_id,\n                node: d.node_id,\n                metric: \"VPD\"\n            },\n            fields: {\n                value: parseFloat(vpd.toFixed(3))\n            }\n        }\n    );\n}\n\n// Average Bag_Rh (from Bag_Rh1â€“4), store only Avg_Bag_Rh\nconst bagRhKeys = ['Bag_Rh1', 'Bag_Rh2', 'Bag_Rh3', 'Bag_Rh4'];\nlet bagRhSum = 0;\nlet bagRhCount = 0;\n\nfor (const key of bagRhKeys) {\n    const value = d[key];\n    if (typeof value === 'number') {\n        bagRhSum += value;\n        bagRhCount++;\n    }\n}\n\nif (bagRhCount > 0) {\n    const avg = bagRhSum / bagRhCount;\n    output.push({\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse: d.greenhouse_id,\n            node: d.node_id,\n            metric: \"Avg_Bag_Rh\"\n        },\n        fields: {\n            value: parseFloat(avg.toFixed(3))\n        }\n    });\n}\n\nmsg.payload = output;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 360,
        "wires": [
            [
                "a836c0c252041385"
            ]
        ]
    },
    {
        "id": "a836c0c252041385",
        "type": "influxdb batch",
        "z": "d1d9b412263f5851",
        "influxdb": "28b3ebc016f19340",
        "precision": "",
        "retentionPolicy": "",
        "name": "Influx(PerNodeCalculatedData)",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-agriculture",
        "bucket": "CalculatedData",
        "x": 1050,
        "y": 360,
        "wires": []
    }
]
[
    {
        "id": "d1d9b412263f5851",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1b094c419d097e01",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.20.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": "120",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0c4a20f07ca08fcd",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx_batch node",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": "60",
        "rejectUnauthorized": false
    },
    {
        "id": "4547a1438f843c82",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": "60",
        "rejectUnauthorized": false
    },
    {
        "id": "bc849d2e7bf01c65",
        "type": "mqtt in",
        "z": "d1d9b412263f5851",
        "name": "",
        "topic": "greenhouse/+/node/+/data",
        "qos": "0",
        "datatype": "json",
        "broker": "1b094c419d097e01",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 180,
        "wires": [
            [
                "9ffc594d6035f994"
            ]
        ]
    },
    {
        "id": "9ffc594d6035f994",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Spliting data node wise",
        "func": "const nodeId = msg.payload.node_id;\n\nlet output = [null, null, null, null, null];\n\nswitch (nodeId) {\n    case \"Node01\":\n        output[0] = msg;\n        break;\n    case \"Node02\":\n        output[1] = msg;\n        break;\n    case \"Node03\":\n        output[2] = msg;\n        break;\n    case \"Node04\":\n        output[3] = msg;\n        break;\n    case \"Node05\":\n        output[4] = msg;\n        break;\n    default:\n        node.warn(\"Unknown node_id: \" + nodeId);\n        break;\n}\n\nreturn output;\n\n",
        "outputs": 5,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 180,
        "wires": [
            [
                "408fa21a2cfe3624",
                "48ad17bfd84ebb60",
                "437749256fc6b386"
            ],
            [
                "408fa21a2cfe3624",
                "48ad17bfd84ebb60",
                "437749256fc6b386"
            ],
            [
                "408fa21a2cfe3624",
                "48ad17bfd84ebb60",
                "437749256fc6b386"
            ],
            [
                "408fa21a2cfe3624",
                "48ad17bfd84ebb60",
                "437749256fc6b386"
            ],
            [
                "408fa21a2cfe3624"
            ]
        ]
    },
    {
        "id": "408fa21a2cfe3624",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Influx (data formate)",
        "func": "const greenhouse = msg.payload.greenhouse_id;\nconst nodeId = msg.payload.node_id;\n\nconst sensorFields = { ...msg.payload };\ndelete sensorFields.greenhouse_id;\ndelete sensorFields.node_id;\ndelete sensorFields.timestamp;\n\nmsg.payload = [{\n    measurement: \"greenhouse_data_clean\",\n    tags: {\n        greenhouse_id: greenhouse,\n        node_id: nodeId\n    },\n    fields: sensorFields\n}];\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 180,
        "wires": [
            [
                "a756afd1789ae3bf"
            ]
        ]
    },
    {
        "id": "a756afd1789ae3bf",
        "type": "influxdb batch",
        "z": "d1d9b412263f5851",
        "influxdb": "0c4a20f07ca08fcd",
        "precision": "",
        "retentionPolicy": "",
        "name": "influx batch ",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-agriculture",
        "bucket": "SensorData",
        "x": 1230,
        "y": 180,
        "wires": []
    },
    {
        "id": "48ad17bfd84ebb60",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "VPD writer",
        "func": "const data = msg.payload;\n\nconst T_leaf = data.Leaf_temp;\nconst T_air = data.Air_Temp;\nconst RH = data.Air_Rh;\n\n// Validate input\nif (\n    typeof T_leaf !== 'number' ||\n    typeof T_air !== 'number' ||\n    typeof RH !== 'number' ||\n    !data.greenhouse_id ||\n    !data.node_id\n) {\n    node.error(\"Invalid input data\", msg);\n    return null;\n}\n\n// VPD calculation with intermediate values\nfunction calc_vpd_components(T_air, RH, T_leaf) {\n    const es_air = 0.6108 * Math.exp((17.27 * T_air) / (T_air + 237.3));\n    const es_leaf = 0.6108 * Math.exp((17.27 * T_leaf) / (T_leaf + 237.3));\n    const ea = (RH / 100) * es_air;\n    const vpd = Math.max(0, es_leaf - ea);\n    return {\n        es_air: parseFloat(es_air.toFixed(3)),\n        es_leaf: parseFloat(es_leaf.toFixed(3)),\n        ea: parseFloat(ea.toFixed(3)),\n        vpd: parseFloat(vpd.toFixed(3))\n    };\n}\n\nconst { es_air, es_leaf, ea, vpd } = calc_vpd_components(T_air, RH, T_leaf);\n\n// ➕ Store in global context for averaging later\nlet vpd_context = global.get(\"vpd_values\") || {};\nvpd_context[data.node_id] = {\n    VPD: vpd,\n    es_air: es_air,\n    es_leaf: es_leaf,\n    ea: ea\n};\nglobal.set(\"vpd_values\", vpd_context);\n\n// ✅ Construct payload for InfluxDB (only calculated values)\nmsg.payload = [\n    {\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse_id: data.greenhouse_id,\n            node_id: data.node_id\n        },\n        fields: {\n            VPD: vpd,\n            es_air: es_air,\n            es_leaf: es_leaf,\n            ea: ea\n        }\n    }\n];\n\nnode.warn(`Node=${data.node_id} | VPD=${vpd} | es_air=${es_air} | es_leaf=${es_leaf} | ea=${ea}`);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 260,
        "wires": [
            [
                "8bd9880e362c4b29"
            ]
        ]
    },
    {
        "id": "8bd9880e362c4b29",
        "type": "influxdb batch",
        "z": "d1d9b412263f5851",
        "influxdb": "4547a1438f843c82",
        "precision": "",
        "retentionPolicy": "",
        "name": "CaluclatedData Bucket",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-agriculture",
        "bucket": "CalculatedData",
        "x": 1260,
        "y": 300,
        "wires": []
    },
    {
        "id": "437749256fc6b386",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Average Sensor Values",
        "func": "const newData = msg.payload;\n\nconst keysToAverage = [\n    \"Bag_Temp\",\n    \"Light_Par\",\n    \"Air_Temp\",\n    \"Air_Rh\",\n    \"Leaf_temp\",\n    \"drip_weight\",\n    \"Bag_Rh1\",\n    \"Bag_Rh2\",\n    \"Bag_Rh3\",\n    \"Bag_Rh4\"\n];\n\nlet cache = context.get(\"latestValues\") || {};\ncache[newData.node_id] = newData;\ncontext.set(\"latestValues\", cache);\n\n// Initialize totals\nconst sum = {};\nconst count = {};\nlet rhSum = 0;\nlet rhCount = 0;\n\nfor (const nodeId in cache) {\n    const nodeData = cache[nodeId];\n\n    for (const key of keysToAverage) {\n        const value = nodeData[key];\n        if (typeof value === 'number') {\n            sum[key] = (sum[key] || 0) + value;\n            count[key] = (count[key] || 0) + 1;\n\n            // Special: combine Bag_Rh1–4\n            if (key.startsWith(\"Bag_Rh\")) {\n                rhSum += value;\n                rhCount += 1;\n            }\n        }\n    }\n}\n\n// Compute field-wise averages\nconst avg = {};\nfor (const key of keysToAverage) {\n    if (count[key] > 0) {\n        avg[key] = parseFloat((sum[key] / count[key]).toFixed(2));\n    }\n}\n\n// Add combined Bag_Rh\nif (rhCount > 0) {\n    avg[\"Bag_Rh\"] = parseFloat((rhSum / rhCount).toFixed(2));\n}\n\n// ➕ Average VPD, es_air, es_leaf, ea\nconst vpd_context = global.get(\"vpd_values\") || {};\nconst nodes = [\"Node01\", \"Node02\", \"Node03\", \"Node04\"];\n\nlet vpd_sum = 0, es_air_sum = 0, es_leaf_sum = 0, ea_sum = 0;\nlet valid_count = 0;\n\nfor (const id of nodes) {\n    const entry = vpd_context[id];\n    if (\n        entry &&\n        typeof entry.VPD === \"number\" &&\n        typeof entry.es_air === \"number\" &&\n        typeof entry.es_leaf === \"number\" &&\n        typeof entry.ea === \"number\"\n    ) {\n        vpd_sum += entry.VPD;\n        es_air_sum += entry.es_air;\n        es_leaf_sum += entry.es_leaf;\n        ea_sum += entry.ea;\n        valid_count += 1;\n    }\n}\n\nif (valid_count === nodes.length) {\n    avg[\"VPD_avg\"] = parseFloat((vpd_sum / valid_count).toFixed(3));\n    avg[\"es_air_avg\"] = parseFloat((es_air_sum / valid_count).toFixed(3));\n    avg[\"es_leaf_avg\"] = parseFloat((es_leaf_sum / valid_count).toFixed(3));\n    avg[\"ea_avg\"] = parseFloat((ea_sum / valid_count).toFixed(3));\n}\n\nmsg.payload = [\n    {\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse_id: newData.greenhouse_id,\n            type: \"average\"\n        },\n        fields: avg\n    }\n];\n\nnode.warn(`Averaged from ${Object.keys(cache).length} nodes. VPD group count = ${valid_count}`);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 340,
        "wires": [
            [
                "8bd9880e362c4b29"
            ]
        ]
    }
]
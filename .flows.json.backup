[
    {
        "id": "d1d9b412263f5851",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1b094c419d097e01",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.20.1",
        "port": 1883,
        "clientid": "node-red-greenhouse-client",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": "60",
        "cleansession": false,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0c4a20f07ca08fcd",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "influx_batch node",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": "30",
        "rejectUnauthorized": false,
        "maxConnections": 10,
        "connectionTimeout": 30000,
        "token": "rRTUUvlrnxaHn_J-KJovaY7YbEDb0f70ksxQXrQD4xAIhtAelzxY4WjhCbelC3Mz2uLzlgRs3xSThmbphWNmuA==",
        "org": "iot-agriculture"
    },
    {
        "id": "4547a1438f843c82",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": "30",
        "rejectUnauthorized": false,
        "maxConnections": 10,
        "connectionTimeout": 30000,
        "token": "rRTUUvlrnxaHn_J-KJovaY7YbEDb0f70ksxQXrQD4xAIhtAelzxY4WjhCbelC3Mz2uLzlgRs3xSThmbphWNmuA==",
        "org": "iot-agriculture"
    },
    {
        "id": "bc849d2e7bf01c65",
        "type": "mqtt in",
        "z": "d1d9b412263f5851",
        "name": "",
        "topic": "greenhouse/+/node/+/data",
        "qos": "0",
        "datatype": "json",
        "broker": "1b094c419d097e01",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 220,
        "wires": [
            [
                "9ffc594d6035f994"
            ]
        ]
    },
    {
        "id": "9ffc594d6035f994",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Spliting data node wise",
        "func": "// High-performance data routing by node ID\nconst nodeId = msg.payload.node_id;\n\n// Pre-allocated output array for maximum performance\nlet output = [null, null, null, null, null];\n\n// Direct switch for optimal routing performance\nswitch (nodeId) {\n    case \"Node01\":\n        output[0] = msg;\n        break;\n    case \"Node02\":\n        output[1] = msg;\n        break;\n    case \"Node03\":\n        output[2] = msg;\n        break;\n    case \"Node04\":\n        output[3] = msg;\n        break;\n    case \"Node05\":\n        output[4] = msg;\n        break;\n    default:\n        // Skip unknown nodes silently for performance\n        break;\n}\n\nreturn output;",
        "outputs": 5,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 220,
        "wires": [
            [
                "48ad17bfd84ebb60",
                "437749256fc6b386",
                "408fa21a2cfe3624"
            ],
            [
                "48ad17bfd84ebb60",
                "437749256fc6b386",
                "408fa21a2cfe3624"
            ],
            [
                "48ad17bfd84ebb60",
                "437749256fc6b386",
                "408fa21a2cfe3624"
            ],
            [
                "48ad17bfd84ebb60",
                "437749256fc6b386",
                "408fa21a2cfe3624"
            ],
            [
                "48ad17bfd84ebb60",
                "408fa21a2cfe3624"
            ]
        ]
    },
    {
        "id": "408fa21a2cfe3624",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Influx (data formate)",
        "func": "// Optimized data formatting for InfluxDB\nconst greenhouse = msg.payload.greenhouse_id;\nconst nodeId = msg.payload.node_id;\n\n// Direct field extraction for maximum performance\nconst sensorFields = { ...msg.payload };\ndelete sensorFields.greenhouse_id;\ndelete sensorFields.node_id;\ndelete sensorFields.timestamp;\n\n// Single-pass payload construction\nmsg.payload = [{\n    measurement: \"greenhouse_data_clean\",\n    tags: {\n        greenhouse_id: greenhouse,\n        node_id: nodeId\n    },\n    fields: sensorFields\n}];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 120,
        "wires": [
            [
                "a756afd1789ae3bf"
            ]
        ]
    },
    {
        "id": "a756afd1789ae3bf",
        "type": "influxdb batch",
        "z": "d1d9b412263f5851",
        "influxdb": "0c4a20f07ca08fcd",
        "precision": "",
        "retentionPolicy": "",
        "name": "influx batch ",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-agriculture",
        "bucket": "SensorData",
        "x": 1250,
        "y": 120,
        "wires": []
    },
    {
        "id": "48ad17bfd84ebb60",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "VPD writer",
        "func": "// High-performance VPD calculation with bulletproof error handling\nconst data = msg.payload;\n\n// Fast validation with early returns\nif (!data || typeof data !== 'object') {\n    return null;\n}\n\nconst T_leaf = data.Leaf_temp;\nconst T_air = data.Air_Temp;\nconst RH = data.Air_Rh;\n\n// Comprehensive input validation\nif (typeof T_leaf !== 'number' || isNaN(T_leaf) || T_leaf < -50 || T_leaf > 80) {\n    return null;\n}\n\nif (typeof T_air !== 'number' || isNaN(T_air) || T_air < -50 || T_air > 80) {\n    return null;\n}\n\nif (typeof RH !== 'number' || isNaN(RH) || RH < 0 || RH > 100) {\n    return null;\n}\n\nif (!data.greenhouse_id || !data.node_id) {\n    return null;\n}\n\n// Optimized VPD calculation with single-pass computation\ntry {\n    // Pre-calculated constants for performance\n    const es_air = 0.6108 * Math.exp((17.27 * T_air) / (T_air + 237.3));\n    const es_leaf = 0.6108 * Math.exp((17.27 * T_leaf) / (T_leaf + 237.3));\n    const ea = (RH / 100) * es_air;\n    const vpd = Math.max(0, es_leaf - ea);\n    \n    // Store in global context for averaging\n    let vpd_context = global.get(\"vpd_values\") || {};\n    vpd_context[data.node_id] = {\n        VPD: parseFloat(vpd.toFixed(3)),\n        es_air: parseFloat(es_air.toFixed(3)),\n        es_leaf: parseFloat(es_leaf.toFixed(3)),\n        ea: parseFloat(ea.toFixed(3)),\n        timestamp: Date.now()\n    };\n    global.set(\"vpd_values\", vpd_context);\n    \n    // Construct optimized payload\n    msg.payload = [{\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse_id: data.greenhouse_id,\n            node_id: data.node_id\n        },\n        fields: {\n            VPD: parseFloat(vpd.toFixed(3)),\n            es_air: parseFloat(es_air.toFixed(3)),\n            es_leaf: parseFloat(es_leaf.toFixed(3)),\n            ea: parseFloat(ea.toFixed(3))\n        }\n    }];\n    \n    return msg;\n} catch (error) {\n    return null; // Silent fail for performance\n}",
        "outputs": 1,
        "timeout": 30,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 140,
        "wires": [
            [
                "8bd9880e362c4b29"
            ]
        ]
    },
    {
        "id": "8bd9880e362c4b29",
        "type": "influxdb batch",
        "z": "d1d9b412263f5851",
        "influxdb": "4547a1438f843c82",
        "precision": "",
        "retentionPolicy": "",
        "name": "CaluclatedData Bucket",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iot-agriculture",
        "bucket": "CalculatedData",
        "x": 1040,
        "y": 200,
        "wires": []
    },
    {
        "id": "437749256fc6b386",
        "type": "function",
        "z": "d1d9b412263f5851",
        "name": "Average Sensor Values",
        "func": "// High-performance sensor averaging with optimized cache management\nconst newData = msg.payload;\n\n// Fast validation\nif (!newData || typeof newData !== 'object' || !newData.node_id || !newData.greenhouse_id) {\n    return null;\n}\n\n// Pre-defined keys for maximum performance\nconst keysToAverage = [\n    \"Bag_Temp\", \"Light_Par\", \"Air_Temp\", \"Air_Rh\", \"Leaf_temp\",\n    \"drip_weight\", \"Bag_Rh1\", \"Bag_Rh2\", \"Bag_Rh3\", \"Bag_Rh4\"\n];\n\n// Optimized cache management with single-pass operations\ntry {\n    let cache = flow.get(\"latestValues\") || {};\n    const currentTime = Date.now();\n    const maxAge = 5 * 60 * 1000; // 5 minutes\n    \n    // Clean old entries and add new data in single pass\n    const cleanedCache = {};\n    for (const nodeId in cache) {\n        const entry = cache[nodeId];\n        if (entry.timestamp && (currentTime - entry.timestamp) <= maxAge) {\n            cleanedCache[nodeId] = entry;\n        }\n    }\n    \n    // Add new data\n    cleanedCache[newData.node_id] = {\n        ...newData,\n        timestamp: currentTime\n    };\n    \n    flow.set(\"latestValues\", cleanedCache);\n    \n    // Optimized averaging with single-pass computation\n    const sum = {};\n    const count = {};\n    let rhSum = 0, rhCount = 0;\n    \n    // Process all nodes in single pass\n    for (const nodeId in cleanedCache) {\n        const nodeData = cleanedCache[nodeId];\n        if (!nodeData || typeof nodeData !== 'object') continue;\n\n        for (const key of keysToAverage) {\n            const value = nodeData[key];\n            if (typeof value === 'number' && !isNaN(value)) {\n                sum[key] = (sum[key] || 0) + value;\n                count[key] = (count[key] || 0) + 1;\n                \n                if (key.startsWith(\"Bag_Rh\")) {\n                    rhSum += value;\n                    rhCount += 1;\n                }\n            }\n        }\n    }\n\n    // Compute averages with validation\n    const avg = {};\n    for (const key of keysToAverage) {\n        if (count[key] > 0) {\n            const average = sum[key] / count[key];\n            if (!isNaN(average) && isFinite(average)) {\n                avg[key] = parseFloat(average.toFixed(2));\n            }\n        }\n    }\n\n    // Add combined Bag_Rh\n    if (rhCount > 0) {\n        const rhAverage = rhSum / rhCount;\n        if (!isNaN(rhAverage) && isFinite(rhAverage)) {\n            avg[\"Bag_Rh\"] = parseFloat(rhAverage.toFixed(2));\n        }\n    }\n\n    // Optimized VPD averaging\n    const vpd_context = global.get(\"vpd_values\") || {};\n    const nodes = [\"Node01\", \"Node02\", \"Node03\", \"Node04\"];\n    \n    let vpd_sum = 0, es_air_sum = 0, es_leaf_sum = 0, ea_sum = 0;\n    let valid_count = 0;\n    \n    for (const id of nodes) {\n        const entry = vpd_context[id];\n        if (entry && entry.timestamp && (currentTime - entry.timestamp) <= maxAge) {\n            if (typeof entry.VPD === \"number\" && !isNaN(entry.VPD)) {\n                vpd_sum += entry.VPD;\n                es_air_sum += entry.es_air || 0;\n                es_leaf_sum += entry.es_leaf || 0;\n                ea_sum += entry.ea || 0;\n                valid_count += 1;\n            }\n        }\n    }\n\n    if (valid_count === nodes.length) {\n        avg[\"VPD_avg\"] = parseFloat((vpd_sum / valid_count).toFixed(3));\n        avg[\"es_air_avg\"] = parseFloat((es_air_sum / valid_count).toFixed(3));\n        avg[\"es_leaf_avg\"] = parseFloat((es_leaf_sum / valid_count).toFixed(3));\n        avg[\"ea_avg\"] = parseFloat((ea_sum / valid_count).toFixed(3));\n    }\n\n    // Construct optimized payload\n    msg.payload = [{\n        measurement: \"calculated_data\",\n        tags: {\n            greenhouse_id: newData.greenhouse_id,\n            type: \"average\"\n        },\n        fields: avg\n    }];\n    \n    return msg;\n    \n} catch (error) {\n    return null; // Silent fail for performance\n}",
        "outputs": 1,
        "timeout": 30,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 280,
        "wires": [
            [
                "8bd9880e362c4b29"
            ]
        ]
    }
]